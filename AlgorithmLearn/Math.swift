//
//  Math.swift
//  AlgorithmLearn
//
//  Created by Mac mini on 2022/8/4.
//

import Foundation

class Math {
    // MARK: - 7. 整数反转（中等）
    /*
     给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
     如果反转后整数超过 32 位的有符号整数的范围，就返回 0。
     假设环境不允许存储 64 位整数（有符号或无符号）。
      
     示例 1：
     输入：x = 123
     输出：321
     
     示例 2：
     输入：x = -123
     输出：-321
     
     示例 3：
     输入：x = 120
     输出：21
     
     示例 4：
     输入：x = 0
     输出：0
      
     提示：
     -231 <= x <= 231 - 1
     */
    static func reverse(_ x: Int) -> Int {
        var res = 0
        var x = x
        while x != 0 {
            if res < Int32.min / 10 || res > Int32.max / 10 {
                return 0
            }
            res = res * 10 + x % 10
            x /= 10
        }
        return res
    }
    
    // MARK: - 9. 回文数
    /*
     给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
     回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
     例如，121 是回文，而 123 不是。
      
     示例 1：
     输入：x = 121
     输出：true
     
     示例 2：
     输入：x = -121
     输出：false
     解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
     
     示例 3：
     输入：x = 10
     输出：false
     解释：从右向左读, 为 01 。因此它不是一个回文数。
      
     提示：
     -231 <= x <= 231 - 1
     进阶：你能不将整数转为字符串来解决这个问题吗？
     */
    static func isPalindrome(_ x: Int) -> Bool {
        if x < 0 || (x != 0 && x % 10 == 0) {
            return false
        }
        var x = x
        var revertNum = 0
        while x > revertNum {
            revertNum = revertNum * 10 + x % 10
            x /= 10
        }
        return x == revertNum || x == revertNum / 10
    }
    
    // MARK: - 479. 最大回文数乘积（困难）
    /*
     给定一个整数 n ，返回 可表示为两个 n 位整数乘积的 最大回文整数 。因为答案可能非常大，所以返回它对 1337 取余 。
     
     示例 1:
     输入：n = 2
     输出：987
     解释：99 x 91 = 9009, 9009 % 1337 = 987
     
     示例 2:
     输入： n = 1
     输出： 9
     
     提示:
     1 <= n <= 8
     */
    static func largestPalindrome(_ n: Int) -> Int {
        if n == 1 { return 9 }
        let upper = Int(powf(10, Float(n))) - 1
        var cur = upper
        while cur > 0 {
            var p = cur
            var x = cur
            while x > 0 {
                p = p * 10 + x % 10
                x /= 10
            }
            var y = upper
            while y * y >= p {
                if p % y == 0 {
                    return p % 1337
                }
                y -= 1
            }
            cur -= 1
        }
        return 0
    }
    
    // MARK: - 564. 寻找最近的回文数（困难）
    /*
     给定一个表示整数的字符串 n ，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。
     “最近的”定义为两个整数差的绝对值最小。
     
     示例 1:
     输入: n = "123"
     输出: "121"
     
     999
     1001
     
     示例 2:
     输入: n = "1"
     输出: "0"
     解释: 0 和 2是最近的回文，但我们返回最小的，也就是 0。
      
     提示:
     1 <= n.length <= 18
     n 只由数字组成
     n 不含前导 0
     n 代表在 [1, 1018 - 1] 范围内的整数
     */
    static func nearestPalindromic(_ n: String) -> String {
        
        return ""
    }
    
    // MARK: - 231. 2 的幂
    /*
     给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。
     如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。

     示例 1：
     输入：n = 1
     输出：true
     解释：20 = 1
     
     示例 2：
     输入：n = 16
     输出：true
     解释：24 = 16
     
     示例 3：
     输入：n = 3
     输出：false
     
     示例 4：
     输入：n = 4
     输出：true
     
     示例 5：
     输入：n = 5
     输出：false
      
     提示：
     -231 <= n <= 231 - 1

     进阶：你能够不使用循环/递归解决此问题吗？
     */
    static func isPowerOfTwo(_ n: Int) -> Bool {
        /*
         // 循环
        guard n > 0 else { return false }
        var x = n
        while x % 2 == 0 {
            x = x / 2
        }
        return x == 1
        */
        // 位运算
        return n > 0 && (n & (n - 1)) == 0
    }
    
    // MARK: - 342. 4的幂
    static func isPowerOfFour(_ n: Int) -> Bool {
        // 构造偶数位全部是1的二进制：10101010
//        return n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0
        // 取余
        return n > 0 && (n & (n - 1)) == 0 && n % 3 == 1
    }
    
    // MARK: - 326. 3 的幂
    static func isPowerOfThree(_ n: Int) -> Bool {
        return n > 0 && 1162261467 % n == 0
    }
    
    // MARK: - 504. 七进制数
    /*
     给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。
     
     示例 1:
     输入: num = 100
     输出: "202"
     
     示例 2:
     输入: num = -7
     输出: "-10"
      1010
     10 / 2 = 5  0
     5 / 2 = 2  1
     2 / 2 = 1 0
     1 / 2 = 0 1
     提示：
     -107 <= num <= 107
     */
    static func convertToBase7(_ num: Int) -> String {
        if num == 0 { return "0" }
        var result = ""
        var x = num
        while x != 0 {
            result.insert(Character("\(abs(x) % 7)"), at: result.startIndex)
            x /= 7
        }
        if num < 0 {
            result.insert(Character("-"), at: result.startIndex)
        }
        return  result
    }
    
    // MARK: - 263. 丑数
    /*
     丑数 就是只包含质因数 2、3 和 5 的正整数。
     给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。

     示例 1：
     输入：n = 6
     输出：true
     解释：6 = 2 × 3
     
     示例 2：
     输入：n = 1
     输出：true
     解释：1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的空集。习惯上将其视作第一个丑数。
     
     示例 3：
     输入：n = 14
     输出：false
     解释：14 不是丑数，因为它包含了另外一个质因数 7 。
     
     提示：
     -231 <= n <= 231 - 1
     */
    static func isUgly(_ n: Int) -> Bool {
        guard n > 0 else { return false }
        var n = n
        while n % 2 == 0 {
            n /= 2
        }
        while n % 3 == 0 {
            n /= 3
        }
        while n % 5 == 0 {
            n /= 5
        }
        return n == 1
    }
    
    // MARK: - 190. 颠倒二进制位
    /*
     颠倒给定的 32 位无符号整数的二进制位。
     提示：
     请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
     在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
      
     示例 1：
     输入：n = 00000010100101000001111010011100
     输出：964176192 (00111001011110000010100101000000)
     解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
          因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
     
     示例 2：
     输入：n = 11111111111111111111111111111101
     输出：3221225471 (10111111111111111111111111111111)
     解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
          因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。

     提示：
     输入是一个长度为 32 的二进制字符串
     
     进阶: 如果多次调用这个函数，你将如何优化你的算法？
     */
    static func reverseBits(_ n: Int) -> Int {
        var res = 0
        for i in 0..<32 {
            res = (res << 1) + (n >> i & 1)
        }
        return res
    }
    
    // MARK: - 191. 位1的个数
    /*
     编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
     提示：
     请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
     在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。
      
     示例 1：
     输入：00000000000000000000000000001011
     输出：3
     解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
     
     示例 2：
     输入：00000000000000000000000010000000
     输出：1
     解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
     
     示例 3：
     输入：11111111111111111111111111111101
     输出：31
     解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
      
     提示：
     输入必须是长度为 32 的 二进制串 。
     */
    static func hammingWeight(_ n: Int) -> Int {
        var res = 0
        var n = n
        for _ in 0..<32 {
            if n & 1 == 1 {
                res += 1
            }
            n = n >> 1
        }
        return res
    }
    
    // MARK: - 476. 数字的补数
    /*
     对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。
     例如，整数 5 的二进制表示是 "101" ，取反后得到 "010" ，再转回十进制表示得到补数 2 。
     给你一个整数 num ，输出它的补数。
     
     示例 1：
     输入：num = 5
     输出：2
     解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
     
     示例 2：
     输入：num = 1
     输出：0
     解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。
     
     提示：
     1 <= num < 231
     */
    static func findComplement(_ num: Int) -> Int {
        
    }
}
